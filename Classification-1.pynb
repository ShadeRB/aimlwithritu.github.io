
 **Wisconsin Diagnostic Breast Cancer (WDBC)** dataset. 
This dataset is commonly used in machine learning tasks related to classification, and it contains several features derived from digitized images of breast tumor cells obtained via fine needle aspirates (FNAs).

Each row in the dataset represents one tumor, with a set of measurements calculated from the cell nuclei present in the image. The dataset has the following columns:
- **ID**: Unique identifier for each tumor sample.
- **Diagnosis**: The classification label for the tumor (Malignant or Benign).
- **Radius Mean, Texture Mean, Perimeter Mean, Area Mean**: Various statistical properties of the tumor.
- **Compactness, Concavity, Symmetry**: Other characteristics calculated from the shape and structure of the tumor cells.

The target column is **Diagnosis**, which we will try to predict based on the other features in the dataset.

This dataset was obtained from the UCI Machine Learning Repository, a well-known resource for datasets in the machine learning community.
----------------------------------------------------------------------------------------------
#Explanation:
#pandas: for data loading and manipulation.
#matplotlib.pyplot: for 2D plotting.
#matplotlib.colors: for assigning different colors to categories.
#mpl_toolkits.mplot3d: for creating 3D scatter plots.

#Data Loading & Exploration 
#Data Visualization (scatter plots)
#KNN manual implementation
#3D plot with more variables
#Using scikit-learn for classification

----------------------------------------------------------------



# Import necessary libraries

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from mpl_toolkits import mplot3d
import numpy as np
from collections import Counter
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score

# ----------------------------
# 1. Load and inspect the data
# ----------------------------

# Load the dataset
cancer = pd.read_csv('wdbc.csv')

# Display first few rows
print(cancer.head())

# Check unique diagnosis values
print("Diagnosis Types:", cancer["diagnosis"].unique())

# ----------------------------
# 2. Create color mapping for diagnosis
# ----------------------------

# Get unique labels and assign a color to each
labels = cancer["diagnosis"].unique().tolist()
colors = list(mcolors.TABLEAU_COLORS.keys())
color_map = {l: colors[i % len(colors)] for i, l in enumerate(labels)}

# ----------------------------
# 3. 2D Scatter Plot
# ----------------------------

# Plot perimeter_mean vs concavity_mean
plt.scatter(cancer["perimeter_mean"], cancer['concavity_mean'], 
            color=cancer["diagnosis"].map(color_map))

# Add custom legend
handles = [plt.Line2D([0], [0], marker='o', color='w', label=label,
                      markersize=10, markerfacecolor=color_map[label])
           for label in labels]

plt.xlabel('Perimeter Mean')
plt.ylabel('Concavity Mean')
plt.title('Scatter Plot of Perimeter Mean vs Concavity Mean')
plt.legend(handles=handles, title='Diagnosis')
plt.show()

# ----------------------------
# 4. Manual KNN Classification
# ----------------------------

# Select relevant features and target
x = cancer[["perimeter_mean", "concavity_mean"]].values
y = cancer["diagnosis"].values

# New data point to classify
new_point = np.array([100, 0.4])

# Compute Euclidean distance from new_point to all points
distances = np.sqrt(np.sum((x - new_point)**2, axis=1))

# Get indices of k nearest neighbors
k = 5
nearest_indices = distances.argsort()[:k]

# Majority vote to determine predicted class
nearest_labels = y[nearest_indices]
predicted_class = Counter(nearest_labels).most_common(1)
print("Predicted class (manual KNN):", predicted_class)

# ----------------------------
# 5. 3D Scatter Plot with Extra Feature
# ----------------------------

# Create 3D plot using 3 features
fig = plt.figure()
ax = plt.axes(projection='3d')

ax.scatter3D(cancer["perimeter_mean"],
             cancer["concavity_mean"],
             cancer["texture_mean"],
             c=cancer["diagnosis"].map(color_map))

ax.set_xlabel("Perimeter Mean")
ax.set_ylabel("Concavity Mean")
ax.set_zlabel("Texture Mean")
plt.title("3D Scatter Plot with 3 Features")
plt.show()

# ----------------------------
# 6. KNN using scikit-learn
# ----------------------------

# Define features and target for sklearn
X = cancer[["perimeter_mean", "concavity_mean"]]
y = cancer["diagnosis"]

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42)

# Create KNN model with k=5
model = KNeighborsClassifier(n_neighbors=5)

# Train the model
model.fit(X_train, y_train)

# Make predictions
y_pred = model.predict(X_test)

# Evaluate model performance
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy (scikit-learn KNN):", accuracy)
----------------------------------------------------------------------


## âœ… Sample Output Summary â€“ KNN Classification on Breast Cancer Dataset

### ðŸ”¹ **Sample Data Preview**

| id       | diagnosis | radius\_mean | texture\_mean | perimeter\_mean | area\_mean | concavity\_mean |
| -------- | --------- | ------------ | ------------- | --------------- | ---------- | --------------- |
| 842302   | M         | 17.99        | 10.38         | 122.8           | 1001.0     | 0.3001          |
| 842517   | M         | 20.57        | 17.77         | 132.9           | 1326.0     | 0.3860          |
| 84300903 | M         | 19.69        | 21.25         | 130.0           | 1203.0     | 0.4365          |
| 84348301 | M         | 11.42        | 20.38         | 77.58           | 386.1      | 0.1425          |
| 84358402 | M         | 20.29        | 14.34         | 135.1           | 1297.0     | 0.3001          |

---

### ðŸ”¹ **Diagnosis Categories**

* **'M'** = Malignant
* **'B'** = Benign

---



### ðŸ”¹ **Manual KNN Prediction Output**

* **Predicted Class**: `'M'`
* **Based on**: 5 Nearest Neighbors

---

### ðŸ”¹ **scikit-learn KNN Classifier Output**

* **Accuracy on Test Set**: `95%`


